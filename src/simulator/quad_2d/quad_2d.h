#pragma once
#include <math.h>

/// Represents the swinging arm
class Quad2D {

private:
  // Position and Orientation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  // Position
  float x = 0; // m
  float z = 2; // m

  // Velocities
  float x_dot = 0; // m/s
  float z_dot = 0; // m/s

  // Accelerations
  float x_ddot = 0; // m/s^2
  float z_ddot = 0; // m/s^2

  // Orientation
  float beta = 0;

  // Angular velocity
  float beta_dot = 0;

  // Angular acceleration
  float beta_ddot = 0;

  // Geometrical properties
  constexpr static float arm_length = 0.171;  // [m]
  constexpr static float inertia_2d = 0.0034; // [kg m^2]

  ///  Mass normalized thrusts
  float actual_thrust = 0;
  float thrust_command = 0;

  /// Torque generated by the motor propellor pair
  float actual_torque = 0;
  float commanded_torque = 0;

  // Variables for dynamics function ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  // Mass of the quadcopter
  constexpr static float mass_ = 0.7;

  // Gravitational constant
  constexpr static float g = 9.81;

  // Air drag coefficient
  constexpr static float drag_coeff = 1.2;

  // Maximum thrust can be produced by the motors
  constexpr static float thrust_max_ = 25;

  // Measured states ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  float x_mes_ = 0;
  float x_dot_mes_ = 0;

  float z_mes_ = 0;
  float z_dot_mes_ = 0;

  float beta_mes_ = 0;
  float beta_dot_mes_ = 0;

public:
  /// Dynamics of the 2D quadcopter
  void dynamics(float thrust_command, float torque_command) {

    // Neglect motor dynamics for now
    actual_thrust = thrust_command;

    // x_dot = x_dot_mes(); [Note: thrust is mass normalized]
    x_ddot = actual_thrust * sin(beta) - drag_coeff * x_dot;

    // z_dot = z_dot_mes();
    if (z < 0) {
      // To prevent freefall into the ground
      z = 0;
      z_dot = 0;
      z_ddot = 0;
    } else
      z_ddot = actual_thrust * cos(beta) - g - drag_coeff * fabs(z_dot);
  }

  // Numerical integration
  void euler_step(float dt) {
    // Declare dt for now

    // Translation
    x = x + x_dot * dt;
    x_dot = x_dot + x_ddot * dt;

    z = z + z_dot * dt;
    z_dot = z_dot + z_ddot * dt;

    // Rotation
    beta = beta + beta_dot * dt;
    beta_dot = beta_dot + beta_ddot * dt;
  }

  // Get sensor measurements by adding artifical noise to the sensors
  void sensor_read() {

    x_mes_ = x;
    x_dot_mes_ = x_dot;

    z_mes_ = z;
    z_dot_mes_ = z_dot;

    beta_mes_ = beta;
    beta_dot_mes_ = beta_dot;
  };

public:
  /// Getter function
  float x_mes() const { return x_mes_; }
  /// Getter function
  float x_dot_mes() const { return x_dot_mes_; }
  /// Getter function
  float z_mes() const { return z_mes_; }
  /// Getter function
  float z_dot_mes() const { return z_dot_mes_; }
  /// Getter function
  float beta_mes() const { return beta_mes_; }
  /// Getter function
  float beta_dot_mes() const { return beta_dot_mes_; }
  /// Getter function
  float thrust_max() const { return thrust_max_; }
  /// Getter function
  float mass() const { return mass_; }

  /// Setter function
  // void set_x_mes(float x_mes) { x_mes_ = x_mes; }
  // /// Setter function
  // void set_x_dot_mes(float x_mes) { x_mes_ = x_mes; }
  // /// Setter function
  // void set_z_mes(float z_mes) { z_mes_ = z_mes; }
  // /// Setter function
  // void set_z_dot_mes(float z_mes) { z_mes_ = z_mes; }
  // /// Setter function
  // void set_beta_mes(float beta_mes) { beta_mes_ = beta_mes; }
  // /// Setter function
  // void set_beta_dot_mes(float beta_mes) { beta_mes_ = beta_mes; }
};